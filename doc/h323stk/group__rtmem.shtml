<!DOCTYPE HTML PUBLIC "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//EN" "hmpro6.dtd">
<HTML>
  <HEAD>
    <TITLE>Objective Open H.323 Stack: Rtmem</TITLE>
    <LINK REL="stylesheet" HREF="stylesheet.css" TYPE="text/css">
  </HEAD>
  <BODY TOPMARGIN="0" LEFTMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
    <CENTER>
      <DIV ID="pageDiv">
        <TABLE BORDER="0" WIDTH="760" CELLSPACING="0" CELLPADDING="0">
          <TR>
            <TD BORDERCOLOR="#D9E4F1"><IMG BORDER="0"
             SRC="./images/Head1.jpg" WIDTH="725" HEIGHT="90"
             ALT="Objective Systems, Inc."></TD>
            <TD WIDTH="100%" BACKGROUND="./images/Head2.jpg">&nbsp;</TD>
          </TR>
        </TABLE>
        <TABLE BORDER="0" WIDTH="760" CELLSPACING="10" CELLPADDING="10">
          <TR><TD>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.shtml"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.shtml"><span>Modules</span></a></li>
      <li><a href="annotated.shtml"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.shtml"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Rtmem<br/>
<small>
[<a class="el" href="group__cruntime.shtml">C Runtime Common Functions</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#gadc9184dda7d78edbf402d056094cc539">memAlloc</a>(pctxt, nbytes)&nbsp;&nbsp;&nbsp;memHeapAlloc(&amp;(pctxt)-&gt;pTypeMemHeap,nbytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory.  <a href="#gadc9184dda7d78edbf402d056094cc539"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#ga1ab2ae49b6ba33c5a6740cb9c79f23ad">memAllocZ</a>(pctxt, nbytes)&nbsp;&nbsp;&nbsp;memHeapAllocZ(&amp;(pctxt)-&gt;pTypeMemHeap,nbytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and zero memory.  <a href="#ga1ab2ae49b6ba33c5a6740cb9c79f23ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#ga5a0810cd281526083d4e7cf8e801304e">memAllocType</a>(pctxt, ctype)&nbsp;&nbsp;&nbsp;(ctype*)memHeapAlloc(&amp;(pctxt)-&gt;pTypeMemHeap,sizeof(ctype))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate type.  <a href="#ga5a0810cd281526083d4e7cf8e801304e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#ga771b2a6e3357c5569de3b8bb9fa77374">memAllocTypeZ</a>(pctxt, ctype)&nbsp;&nbsp;&nbsp;(ctype*)memHeapAllocZ(&amp;(pctxt)-&gt;pTypeMemHeap,sizeof(ctype))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate type and zero memory.  <a href="#ga771b2a6e3357c5569de3b8bb9fa77374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#gaa150962db9e4621eab23e31986d0d976">memRealloc</a>(pctxt, mem_p, nbytes)&nbsp;&nbsp;&nbsp;memHeapRealloc(&amp;(pctxt)-&gt;pTypeMemHeap, (void*)mem_p, nbytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocate memory.  <a href="#gaa150962db9e4621eab23e31986d0d976"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#ga088d3d681c22a0c987d6b6136c5f0263">memFreePtr</a>(pctxt, mem_p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory pointer.  <a href="#ga088d3d681c22a0c987d6b6136c5f0263"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#gac49b973c93cc035daa33af99af431df8">memFree</a>(pctxt)&nbsp;&nbsp;&nbsp;memHeapFreeAll(&amp;(pctxt)-&gt;pTypeMemHeap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory associated with a context.  <a href="#gac49b973c93cc035daa33af99af431df8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#ga1bd754cdd038430ebfd3d8882805ac83">memReset</a>(pctxt)&nbsp;&nbsp;&nbsp;memHeapReset(&amp;(pctxt)-&gt;pTypeMemHeap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset memory associated with a context.  <a href="#ga1bd754cdd038430ebfd3d8882805ac83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58cffb68d65d2a832f930ad345b13288"></a><!-- doxytag: member="rtmem::OSCDECL" ref="ga58cffb68d65d2a832f930ad345b13288" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSCDECL</b></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe447309103a7b62eef92421e7a805e1"></a><!-- doxytag: member="rtmem::OSMallocFunc" ref="gafe447309103a7b62eef92421e7a805e1" args="(size_t size)" -->
typedef void *OSCDECL *&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSMallocFunc</b> (size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad73d249c7c148aade3d49f2425fccb85"></a><!-- doxytag: member="rtmem::OSReallocFunc" ref="gad73d249c7c148aade3d49f2425fccb85" args="(void *ptr, size_t size)" -->
typedef void *OSCDECL *&nbsp;</td><td class="memItemRight" valign="bottom"><b>OSReallocFunc</b> (void *ptr, size_t size)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2d2004dacd1755bca8ac32dcc90b4645"></a><!-- doxytag: member="rtmem::void" ref="ga2d2004dacd1755bca8ac32dcc90b4645" args="(OSCDECL *OSFreeFunc)(void *ptr)" -->
typedef&nbsp;</td><td class="memItemRight" valign="bottom"><b>void</b> (OSCDECL *OSFreeFunc)(void *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7748bb0d1dca2f88c60edb2a77dd8e3e"></a><!-- doxytag: member="rtmem::memHeapAddRef" ref="ga7748bb0d1dca2f88c60edb2a77dd8e3e" args="(void **ppvMemHeap)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapAddRef</b> (void **ppvMemHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fac0b43e84050706adf6f9176e440bf"></a><!-- doxytag: member="rtmem::memHeapAlloc" ref="ga6fac0b43e84050706adf6f9176e440bf" args="(void **ppvMemHeap, int nbytes)" -->
EXTERN void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapAlloc</b> (void **ppvMemHeap, int nbytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2b32f76c87c0ef95f562d5006f571a5"></a><!-- doxytag: member="rtmem::memHeapAllocZ" ref="gad2b32f76c87c0ef95f562d5006f571a5" args="(void **ppvMemHeap, int nbytes)" -->
EXTERN void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapAllocZ</b> (void **ppvMemHeap, int nbytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga506146c53cc5584ba97d52085cd9c69c"></a><!-- doxytag: member="rtmem::memHeapCheckPtr" ref="ga506146c53cc5584ba97d52085cd9c69c" args="(void **ppvMemHeap, void *mem_p)" -->
EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapCheckPtr</b> (void **ppvMemHeap, void *mem_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37c3c8b48bc5bc79c1aac774e6aa7358"></a><!-- doxytag: member="rtmem::memHeapCreate" ref="ga37c3c8b48bc5bc79c1aac774e6aa7358" args="(void **ppvMemHeap)" -->
EXTERN int&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapCreate</b> (void **ppvMemHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad080dea839f6eda5954af7d8f43a3154"></a><!-- doxytag: member="rtmem::memHeapFreeAll" ref="gad080dea839f6eda5954af7d8f43a3154" args="(void **ppvMemHeap)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapFreeAll</b> (void **ppvMemHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac13f9649b3b64f05d7531a3ee82f826a"></a><!-- doxytag: member="rtmem::memHeapFreePtr" ref="gac13f9649b3b64f05d7531a3ee82f826a" args="(void **ppvMemHeap, void *mem_p)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapFreePtr</b> (void **ppvMemHeap, void *mem_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65e73373e5c1f90d03bbbb4dffd7fd27"></a><!-- doxytag: member="rtmem::memHeapRealloc" ref="ga65e73373e5c1f90d03bbbb4dffd7fd27" args="(void **ppvMemHeap, void *mem_p, int nbytes_)" -->
EXTERN void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapRealloc</b> (void **ppvMemHeap, void *mem_p, int nbytes_)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga280a958c44770081fb7441fc5ff26016"></a><!-- doxytag: member="rtmem::memHeapRelease" ref="ga280a958c44770081fb7441fc5ff26016" args="(void **ppvMemHeap)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapRelease</b> (void **ppvMemHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd45a65087aac5007d7987c3875f2a90"></a><!-- doxytag: member="rtmem::memHeapReset" ref="gadd45a65087aac5007d7987c3875f2a90" args="(void **ppvMemHeap)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapReset</b> (void **ppvMemHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga447f21a866d2f328925229539b1a8902"></a><!-- doxytag: member="rtmem::memHeapMarkSaved" ref="ga447f21a866d2f328925229539b1a8902" args="(void **ppvMemHeap, const void *mem_p, ASN1BOOL saved)" -->
EXTERN void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapMarkSaved</b> (void **ppvMemHeap, const void *mem_p, ASN1BOOL saved)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeca174dd3de2ed5b3106c27ad44cfd7b"></a><!-- doxytag: member="rtmem::memHeapSetProperty" ref="gaeca174dd3de2ed5b3106c27ad44cfd7b" args="(void **ppvMemHeap, ASN1UINT propId, void *pProp)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapSetProperty</b> (void **ppvMemHeap, ASN1UINT propId, void *pProp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#gae5aa2674a0b19177b3fe8ce17b58581a">memSetAllocFuncs</a> (OSMallocFunc malloc_func, OSReallocFunc realloc_func, OSFreeFunc free_func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the pointers to standard allocation functions.  <a href="#gae5aa2674a0b19177b3fe8ce17b58581a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga084bf127d0dd55e9a369581060d7eae0"></a><!-- doxytag: member="rtmem::memFreeOpenSeqExt" ref="ga084bf127d0dd55e9a369581060d7eae0" args="(OOCTXT *pctxt, DList *pElemList)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memFreeOpenSeqExt</b> (<a class="el" href="structOOCTXT.shtml">OOCTXT</a> *pctxt, DList *pElemList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc849164622439fc7e1e828342227fe7"></a><!-- doxytag: member="rtmem::memHeapSetFlags" ref="gafc849164622439fc7e1e828342227fe7" args="(OOCTXT *pctxt, ASN1UINT flags)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapSetFlags</b> (<a class="el" href="structOOCTXT.shtml">OOCTXT</a> *pctxt, ASN1UINT flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3dd6a6a42e4d1cceb748197e0e382304"></a><!-- doxytag: member="rtmem::memHeapClearFlags" ref="ga3dd6a6a42e4d1cceb748197e0e382304" args="(OOCTXT *pctxt, ASN1UINT flags)" -->
EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><b>memHeapClearFlags</b> (<a class="el" href="structOOCTXT.shtml">OOCTXT</a> *pctxt, ASN1UINT flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXTERN void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#ga913b4eb119139b70b272f4e4e9c3618d">memHeapSetDefBlkSize</a> (<a class="el" href="structOOCTXT.shtml">OOCTXT</a> *pctxt, ASN1UINT blkSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the pointer to standard allocation functions.  <a href="#ga913b4eb119139b70b272f4e4e9c3618d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXTERN ASN1UINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtmem.shtml#gaef349a1ad2b14fa09d312aad1b1d1fd1">memHeapGetDefBlkSize</a> (<a class="el" href="structOOCTXT.shtml">OOCTXT</a> *pctxt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the actual granularity of memory blocks.  <a href="#gaef349a1ad2b14fa09d312aad1b1d1fd1"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gadc9184dda7d78edbf402d056094cc539"></a><!-- doxytag: member="ooasn1.h::memAlloc" ref="gadc9184dda7d78edbf402d056094cc539" args="(pctxt, nbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memAlloc</td>
          <td>(</td>
          <td class="paramtype">pctxt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nbytes&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;memHeapAlloc(&amp;(pctxt)-&gt;pTypeMemHeap,nbytes)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate memory. </p>
<p>This macro allocates the given number of bytes. It is similar to the C <code>malloc</code> run-time function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>- Number of bytes of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Void pointer to allocated memory or NULL if insufficient memory was available to fulfill the request. </dd></dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00811">811</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ab2ae49b6ba33c5a6740cb9c79f23ad"></a><!-- doxytag: member="ooasn1.h::memAllocZ" ref="ga1ab2ae49b6ba33c5a6740cb9c79f23ad" args="(pctxt, nbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memAllocZ</td>
          <td>(</td>
          <td class="paramtype">pctxt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nbytes&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;memHeapAllocZ(&amp;(pctxt)-&gt;pTypeMemHeap,nbytes)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and zero memory. </p>
<p>This macro allocates the given number of bytes and then initializes the memory block to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>- Number of bytes of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Void pointer to allocated memory or NULL if insufficient memory was available to fulfill the request. </dd></dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00823">823</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a0810cd281526083d4e7cf8e801304e"></a><!-- doxytag: member="ooasn1.h::memAllocType" ref="ga5a0810cd281526083d4e7cf8e801304e" args="(pctxt, ctype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memAllocType</td>
          <td>(</td>
          <td class="paramtype">pctxt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ctype&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(ctype*)memHeapAlloc(&amp;(pctxt)-&gt;pTypeMemHeap,sizeof(ctype))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate type. </p>
<p>This macro allocates memory to hold a variable of the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctype</em>&nbsp;</td><td>- Name of C typedef </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Pointer to allocated memory or NULL if insufficient memory was available to fulfill the request. </dd></dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00835">835</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga771b2a6e3357c5569de3b8bb9fa77374"></a><!-- doxytag: member="ooasn1.h::memAllocTypeZ" ref="ga771b2a6e3357c5569de3b8bb9fa77374" args="(pctxt, ctype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memAllocTypeZ</td>
          <td>(</td>
          <td class="paramtype">pctxt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ctype&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(ctype*)memHeapAllocZ(&amp;(pctxt)-&gt;pTypeMemHeap,sizeof(ctype))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate type and zero memory. </p>
<p>This macro allocates memory to hold a variable of the given type and initializes the allocated memory to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctype</em>&nbsp;</td><td>- Name of C typedef </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Pointer to allocated memory or NULL if insufficient memory was available to fulfill the request. </dd></dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00847">847</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa150962db9e4621eab23e31986d0d976"></a><!-- doxytag: member="ooasn1.h::memRealloc" ref="gaa150962db9e4621eab23e31986d0d976" args="(pctxt, mem_p, nbytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memRealloc</td>
          <td>(</td>
          <td class="paramtype">pctxt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mem_p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nbytes&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;memHeapRealloc(&amp;(pctxt)-&gt;pTypeMemHeap, (void*)mem_p, nbytes)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reallocate memory. </p>
<p>This macro reallocates a memory block (either expands or contracts) to the given number of bytes. It is similar to the C <code>realloc</code> run-time function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem_p</em>&nbsp;</td><td>- Pointer to memory block to reallocate. This must have been allocated using the memHeapAlloc macro or the memHeapAlloc function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>- Number of bytes of memory to which the block is to be resized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Void pointer to allocated memory or NULL if insufficient memory was available to fulfill the request. This may be the same as the pmem pointer that was passed in if the block did not need to be relocated. </dd></dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00864">864</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga088d3d681c22a0c987d6b6136c5f0263"></a><!-- doxytag: member="ooasn1.h::memFreePtr" ref="ga088d3d681c22a0c987d6b6136c5f0263" args="(pctxt, mem_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memFreePtr</td>
          <td>(</td>
          <td class="paramtype">pctxt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mem_p&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (memHeapCheckPtr (&amp;(pctxt)-&gt;pTypeMemHeap, (<span class="keywordtype">void</span>*)mem_p)) \
memHeapFreePtr(&amp;(pctxt)-&gt;pTypeMemHeap, (<span class="keywordtype">void</span>*)mem_p)
</pre></div>
<p>Free memory pointer. </p>
<p>This macro frees memory at the given pointer. The memory must have been allocated using the memHeapAlloc (or similar) macros or the mem memory allocation macros. This macro is similar to the C <code>free</code> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem_p</em>&nbsp;</td><td>- Pointer to memory block to free. This must have been allocated using the memHeapAlloc or memAlloc macro or the memHeapAlloc function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00878">878</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac49b973c93cc035daa33af99af431df8"></a><!-- doxytag: member="ooasn1.h::memFree" ref="gac49b973c93cc035daa33af99af431df8" args="(pctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memFree</td>
          <td>(</td>
          <td class="paramtype">pctxt&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;memHeapFreeAll(&amp;(pctxt)-&gt;pTypeMemHeap)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory associated with a context. </p>
<p>This macro frees all memory held within a context. This is all memory allocated using the memHeapAlloc (and similar macros) and the mem memory allocation functions using the given context variable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00890">890</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1bd754cdd038430ebfd3d8882805ac83"></a><!-- doxytag: member="ooasn1.h::memReset" ref="ga1bd754cdd038430ebfd3d8882805ac83" args="(pctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define memReset</td>
          <td>(</td>
          <td class="paramtype">pctxt&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;memHeapReset(&amp;(pctxt)-&gt;pTypeMemHeap)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset memory associated with a context. </p>
<p>This macro resets all memory held within a context. This is all memory allocated using the memHeapAlloc (and similar macros) and the mem memory allocation functions using the given context variable.</p>
<p>The difference between this and the ASN1MEMFREE macro is that the memory blocks held within the context are not actually freed. Internal pointers are reset so the existing blocks can be reused. This can provide a performace improvement for repetitive tasks such as decoding messages in a loop.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>- Pointer to a context block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ooasn1_8h_source.shtml#l00907">907</a> of file <a class="el" href="ooasn1_8h_source.shtml">ooasn1.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae5aa2674a0b19177b3fe8ce17b58581a"></a><!-- doxytag: member="ooasn1.h::memSetAllocFuncs" ref="gae5aa2674a0b19177b3fe8ce17b58581a" args="(OSMallocFunc malloc_func, OSReallocFunc realloc_func, OSFreeFunc free_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN void memSetAllocFuncs </td>
          <td>(</td>
          <td class="paramtype">OSMallocFunc&nbsp;</td>
          <td class="paramname"> <em>malloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OSReallocFunc&nbsp;</td>
          <td class="paramname"> <em>realloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OSFreeFunc&nbsp;</td>
          <td class="paramname"> <em>free_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the pointers to standard allocation functions. </p>
<p>These functions are used to allocate/reallocate/free the memory blocks. By default, standard C functions - 'malloc', 'realloc' and 'free' - are used. But if some platforms do not support these functions (or some other reasons exist) they can be overloaded. The functions being overloaded should have the same prototypes as standard ones.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>malloc_func</em>&nbsp;</td><td>Pointer to the memory allocation function ('malloc' by default). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>realloc_func</em>&nbsp;</td><td>Pointer to the memory reallocation function ('realloc' by default). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_func</em>&nbsp;</td><td>Pointer to the memory deallocation function ('free' by default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga913b4eb119139b70b272f4e4e9c3618d"></a><!-- doxytag: member="ooasn1.h::memHeapSetDefBlkSize" ref="ga913b4eb119139b70b272f4e4e9c3618d" args="(OOCTXT *pctxt, ASN1UINT blkSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN void memHeapSetDefBlkSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOOCTXT.shtml">OOCTXT</a> *&nbsp;</td>
          <td class="paramname"> <em>pctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASN1UINT&nbsp;</td>
          <td class="paramname"> <em>blkSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the pointer to standard allocation functions. </p>
<p>These functions are used to allocate/reallocate/free the memory blocks. By default, standard C functions - malloc, realloc, and free - are used. But if some platforms do not support these functions or some other reasons exist) they can be overloaded. The functions being overloaded should have the same prototypes as standard ones.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>Pointer to a context block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blkSize</em>&nbsp;</td><td>The currently used minimum size and the granularity of memory blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef349a1ad2b14fa09d312aad1b1d1fd1"></a><!-- doxytag: member="ooasn1.h::memHeapGetDefBlkSize" ref="gaef349a1ad2b14fa09d312aad1b1d1fd1" args="(OOCTXT *pctxt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN ASN1UINT memHeapGetDefBlkSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOOCTXT.shtml">OOCTXT</a> *&nbsp;</td>
          <td class="paramname"> <em>pctxt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the actual granularity of memory blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pctxt</em>&nbsp;</td><td>Pointer to a context block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--END DOXYGEN -->

</td></tr></table>
<HR WIDTH="80%" COLOR="#080A9A">
  <CENTER><FONT FACE="Arial" SIZE="-2">This file was last modified on
    10 Dec 2010.<BR> Objective Open H.323 Stack, 0.9.1 </FONT></CENTER></td>
</tr> </table></center></BODY>
</HTML>
